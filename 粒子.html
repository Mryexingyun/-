
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹åŠ¿æ§åˆ¶ç²’å­ç³»ç»Ÿ </title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ (éšè—ï¼Œä»…ä¾› MediaPipeä½¿ç”¨) */
        #video-container { position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; border-radius: 10px; overflow: hidden; transform: scaleX(-1); opacity: 0; /* é»˜è®¤éšè— */ }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* UI Loading / é”™è¯¯æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 10;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid #00ffff;
        }

        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 5;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; cursor: pointer; border-radius: 5px; transition: all 0.3s;
        }
        #fullscreen-btn:hover { background: rgba(0, 255, 255, 0.3); }
        
        /* æ‰‹åŠ¿æç¤º */
        #gesture-hint {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); z-index: 2; background: rgba(0,0,0,0.5);
            padding: 8px 15px; border-radius: 20px; font-size: 14px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">
        æ­£åœ¨å¯åŠ¨ç²’å­ç³»ç»Ÿæ ¸å¿ƒ...
        <br><span style="font-size:14px; opacity:0.7">è¯·ç¡®ä¿ä½¿ç”¨ http://localhost è¿è¡Œå¹¶å…è®¸æ‘„åƒå¤´æƒé™ã€‚</span>
    </div>
    <div id="gesture-hint" style="display:none;">ğŸ– å¼ å¼€æ‰‹æŒï¼šæ‰©æ•£ | ğŸ‘Œ æåˆæ‰‹æŒ‡ï¼šèšæ‹¢</div>
    <div id="video-container"><video id="input-video"></video></div>
    <div id="canvas-container"></div>
    <button id="fullscreen-btn">â›¶ å…¨å±ä½“éªŒ</button>

    <script>
        // --- 1. å…¨å±€å˜é‡ä¸é…ç½® ---
        const config = {
            particleCount: 30000,
            particleSize: 2.5,
            color: '#00ffff',
            shape: 'heart',
            expansion: 1.0, // ç”±æ‰‹åŠ¿æ§åˆ¶
            autoRotate: true,
            handControlEnabled: false // æ ‡è®°æ‰‹åŠ¿æ˜¯å¦æˆåŠŸå¯åŠ¨
        };

        let scene, camera, renderer, material, points;
        let handExpansionTarget = 1.0; 
        let currentExpansion = 1.0;    
        let isMorphing = false;

        // --- 2. Three.js åˆå§‹åŒ– ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            initParticles();
            initGUI();
            
            window.addEventListener('resize', onWindowResize, false);
            
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else if (document.exitFullscreen) document.exitFullscreen();
            });
        }

        // --- 3. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ (å‡ ä½•ä¸Shader) ---
        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const positionsOriginal = new Float32Array(config.particleCount * 3);
            const positionsTarget = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            const randoms = new Float32Array(config.particleCount); 

            const colorObj = new THREE.Color(config.color);

            for (let i = 0; i < config.particleCount; i++) {
                // åˆå§‹ä½ç½®ï¼šéšæœºçƒä½“
                const r = 100 * Math.cbrt(Math.random()); 
                positionsOriginal[i * 3] = (Math.random() - 0.5) * r;
                positionsOriginal[i * 3 + 1] = (Math.random() - 0.5) * r;
                positionsOriginal[i * 3 + 2] = (Math.random() - 0.5) * r;

                // é¢œè‰²å’Œéšæœºå€¼
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
                randoms[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positionsOriginal, 3));
            geometry.setAttribute('targetPos', new THREE.BufferAttribute(positionsTarget, 3)); 
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨ (Vertex Shader for Morphing and Expansion)
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uSize: { value: config.particleSize * window.devicePixelRatio },
                    uColor: { value: new THREE.Color(config.color) },
                    uExpansion: { value: 1.0 }, 
                    uMorphFactor: { value: 0.0 } 
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uSize;
                    uniform float uExpansion;
                    uniform float uMorphFactor;
                    attribute vec3 targetPos;
                    attribute float aRandom;
                    attribute vec3 color;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        
                        // å½¢çŠ¶æ’å€¼: ä»å½“å‰ä½ç½®(position)åˆ°ç›®æ ‡ä½ç½®(targetPos)
                        vec3 pos = mix(position, targetPos, uMorphFactor);
                        
                        // å‘¼å¸/å™ªç‚¹æ•ˆæœ
                        float noise = sin(uTime * 2.0 + aRandom * 10.0) * 0.2;
                        
                        // æ‰‹åŠ¿ç¼©æ”¾é€»è¾‘ï¼šuExpansion æ§åˆ¶æ‰©æ•£ç¨‹åº¦ (0.2x åˆ° 2.2x)
                        vec3 finalPos = pos * uExpansion + (normal * noise);

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_PointSize = uSize * (20.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 2.0);
                        
                        gl_FragColor = vec4(uColor, glow); 
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
            
            generateTargetShape('heart');
            startMorphAnimation();
        }

        // --- 4. å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
        // (ä¿æŒä¸åŸç‰ˆä¸€è‡´ï¼Œä½¿ç”¨æ•°å­¦å…¬å¼ç”Ÿæˆå½¢çŠ¶)
        function generateTargetShape(shapeName) {
            const positions = points.geometry.attributes.targetPos.array;
            const count = config.particleCount;

            for (let i = 0; i < count; i++) {
                let x, y, z;
                const idx = i * 3;

                if (shapeName === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    const p = Math.random() * Math.PI; 
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = 5 * Math.cos(p) * Math.sin(t); 
                    const scale = Math.random();
                    x *= scale * 1.5; y *= scale * 1.5; z *= scale * 1.5;
                } 
                else if (shapeName === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 10 * Math.sin(3 * theta) * Math.sin(4 * phi) + 12;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi) * 0.5;
                }
                else if (shapeName === 'planet') {
                    if (Math.random() > 0.3) {
                        const r = 10;
                        const u = Math.random(), v = Math.random();
                        const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 14 + Math.random() * 8;
                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        y = (Math.random() - 0.5) * 0.5;
                    }
                }
                else if (shapeName === 'buddha') {
                    // ä½¿ç”¨ Torus Knot æ¨¡æ‹Ÿå¤æ‚ç¦…æ„ç»“æ„
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    const p = 2, q = 3; 
                    const r = 8 + 3 * Math.cos(q * u);
                    x = r * Math.cos(p * u);
                    y = r * Math.sin(p * u);
                    z = 5 * Math.sin(q * u); 
                    let tempY = y; y = z; z = tempY; 
                }
                else if (shapeName === 'fireworks') {
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    const r = 25 * Math.pow(Math.random(), 0.3); 
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                positions[idx] = x;
                positions[idx+1] = y;
                positions[idx+2] = z;
            }
            
            points.geometry.attributes.targetPos.needsUpdate = true;
        }

        // ç®€å•çš„å˜æ¢åŠ¨ç”»é€»è¾‘
        function startMorphAnimation() {
            let progress = 0;
            isMorphing = true;
            
            function animateMorph() {
                if (!isMorphing) return;
                progress += 0.02;
                if (progress >= 1) {
                    progress = 1;
                    isMorphing = false;
                }
                material.uniforms.uMorphFactor.value = progress;
                if (isMorphing) requestAnimationFrame(animateMorph);
            }
            animateMorph();
        }

        function switchShape(name) {
            material.uniforms.uMorphFactor.value = 0; 
            generateTargetShape(name);
            startMorphAnimation();
        }

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                // ç¡®ä¿æ¨¡å‹æ–‡ä»¶ä»æœ€ç¨³å®šçš„ unpkg æºåŠ è½½ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„ Google æº
                return `https://unpkg.com/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandsResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320, height: 240
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('gesture-hint').style.display = 'block';
                    config.handControlEnabled = true;
                })
                .catch(err => {
                    // æ‘„åƒå¤´/æ¨¡å‹åŠ è½½å¤±è´¥çš„ä¼˜é›…é™çº§å¤„ç†
                    console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œæ”¹ç”¨è‡ªåŠ¨æ¨¡å¼ï¼š", err);
                    document.getElementById('loading').style.cssText = `
                        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        color: #ff5555; font-size: 20px; z-index: 10; text-align: center;
                    `;
                    document.getElementById('loading').innerHTML = "ğŸš¨ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼<br>è¯·æ£€æŸ¥æƒé™æˆ–ç½‘ç»œè¿æ¥ï¼ˆMediaPipeæ¨¡å‹åŠ è½½å¤±è´¥ï¼‰ã€‚<br>ç²’å­ç³»ç»Ÿå·²å¯åŠ¨ï¼Œä½†æ‰‹åŠ¿æ§åˆ¶ä¸å¯ç”¨ã€‚";
                    // ç¦ç”¨æ‰‹åŠ¿æ§åˆ¶
                    config.handControlEnabled = false;
                });
        }

        function onHandsResults(results) {
            if (!config.handControlEnabled) return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                // è®¡ç®—è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                const minDist = 0.05;
                const maxDist = 0.25;
                let normalized = (distance - minDist) / (maxDist - minDist);
                normalized = Math.max(0, Math.min(1, normalized)); 
                
                // æ˜ å°„åˆ°å…·ä½“çš„ Shader å‚æ•°èŒƒå›´ (0.2x åˆ° 2.2x)
                handExpansionTarget = 0.2 + (normalized * 2.0); 
            } else {
                // å¦‚æœæ²¡æœ‰æ‰‹ï¼Œç¼“æ…¢æ¢å¤é»˜è®¤å¤§å°
                handExpansionTarget = 1.0;
            }
        }

        // --- 6. UI é¢æ¿ ---
        function initGUI() {
            const gui = new lil.GUI({ title: 'æ§åˆ¶é¢æ¿' });
            
            const shapeFolder = gui.addFolder('æ¨¡å‹é€‰æ‹©');
            const shapes = { 
                'â¤ çˆ±å¿ƒ': 'heart', 'â€ èŠ±æœµ': 'flower', 'ğŸª ç‹æ˜Ÿ': 'planet', 
                'ğŸ§˜ ä½›åƒ(æ„è±¡)': 'buddha', 'ğŸ† çƒŸèŠ±': 'fireworks' 
            };
            
            config.guiShape = 'heart';
            shapeFolder.add(config, 'guiShape', shapes).name('å½“å‰å½¢çŠ¶').onChange(val => switchShape(val));

            const styleFolder = gui.addFolder('æ ·å¼è°ƒæ•´');
            styleFolder.addColor(config, 'color').name('ç²’å­é¢œè‰²').onChange(val => {
                material.uniforms.uColor.value.set(val);
            });
            styleFolder.add(config, 'particleSize', 0.5, 5.0).name('ç²’å­å¤§å°').onChange(val => {
                material.uniforms.uSize.value = val * window.devicePixelRatio;
            });
            styleFolder.add(config, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬');
        }

        // --- 7. ä¸»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            
            // å¹³æ»‘æ‰‹åŠ¿æ•°æ® (Lerp)
            currentExpansion += (handExpansionTarget - currentExpansion) * 0.1;
            
            if (material) {
                material.uniforms.uTime.value = time;
                // åªæœ‰åœ¨æ‰‹åŠ¿æ§åˆ¶æˆåŠŸå¯åŠ¨æ—¶ï¼Œæ‰ä½¿ç”¨æ‰‹åŠ¿å€¼
                material.uniforms.uExpansion.value = config.handControlEnabled ? currentExpansion : 1.0; 
            }

            if (config.autoRotate && points) {
                points.rotation.y = time * 0.1;
                points.rotation.z = time * 0.05;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uSize.value = config.particleSize * window.devicePixelRatio;
        }

        // --- å¯åŠ¨ ---
        // ç¡®ä¿æ‰€æœ‰åº“éƒ½åŠ è½½å®Œæˆåå†è¿è¡Œ
        try {
            initThree();
            initMediaPipe(); 
            animate();
        } catch (e) {
            console.error("ä¸»ç¨‹åºåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ THREE æˆ– lil æ˜¯å¦å®šä¹‰", e);
            document.getElementById('loading').style.color = '#ff5555';
            document.getElementById('loading').innerHTML = "è‡´å‘½é”™è¯¯ï¼šThree.jsæˆ–UIåº“æœªåŠ è½½ï¼<br>è¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°(F12)çš„**ç½‘ç»œ**æ ‡ç­¾ï¼Œç¡®ä¿æ‰€æœ‰JSæ–‡ä»¶çŠ¶æ€ç ä¸º 200ã€‚";
        }
    </script>
</body>
</html>
